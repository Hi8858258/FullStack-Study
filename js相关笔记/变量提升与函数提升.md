# 变量提升与函数提升

```js
f1() //可以调用，函数提升
f2() //不能调用，f2是变量
function f1(){}
var f2 = function(){}
```

# 执行上下文（执行的时候才产生，动态的）

1. 全局执行上下文
   - 在执行全局代码前将window确定为全局执行上下
   - 对全局数据进行预处理
     - var 定义的全局变量 ==> undefined，添加为window属性
     - function声明的全局函数 ==> 赋值（fun），添加为window的方法
     - this ==>赋值（window）
2. 函数执行上下文
   - 在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象
   - 对局部数据进行预处理
     - 形参变量==>赋值（实参）==>添加为执行上下文的属性
     - arguments==>赋值（实参列表）,添加为执行上下文的属性
     - var定义的局部变量==>undefined,添加为执行上下文的属性
     - function声明的函数==>赋值（fun），添加为执行上下文的方法
     - this==>赋值（调用函数的对象
   - 开始执行函数体代码

# 作用域（写编码的时候产生，静态的）

1. 分类
   - 全局作用域
   - 函数作用域
   - 块作用域（ES6才有）
2. 作用
   - 隔离变量：不同作用域下可以存在同名变量

# 作用域与执行上下文的区别

1. 作用域在函数定义的时候就存在了，而执行上下文是在函数调用前才创建

2. 作用域是静态的，只要函数定义好了就一直存在，且不会再变化，执行上下文会在函数调用结束时自动释放

3. 执行上下文（对象）是从属于所在作用域的

4. 作用域是可以嵌套的，但执行环境是要在执行栈里面相互隔离的

   ```js
   var x = 10;
   function fn(){
       console.log(x);
   }
   function show(f){
       var x = 20;
       f()
   }
   show(fn)
   >>>10;
   //因为fn和show函数的作用域是同级的，都在全局作用域下。所以即使fn是在show函数的执行环境中执行，fn也会去到全局作用域里找x
   ```

   ```js
   var obj ={
       fn2:function(){
           console.log(fn2) >>>报错,因为它会去全局作用域里找fn2
           console.log(this.fn2)>>>输出，因为这里的this指向的是obj对象
       }
   }
   ```

   

